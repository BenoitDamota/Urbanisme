.TH "Resolution" 3 "Wed Apr 27 2016" "Urbanisme" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Resolution \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Resolution\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBResolution\fP (const \fBField\fP &_field, const \fBParameters\fP &_params)"
.br
.ti -1c
.RI "unsigned \fBgetRoadDistance\fP (const \fBCoordinates\fP &coord1, const \fBCoordinates\fP &coord2) const "
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBset_params\fP (const \fBParameters\fP &_params)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "unsigned \fBevaluateTotalUsable\fP () const "
.br
.ti -1c
.RI "float \fBmanhattanRatioBetween2Parcels\fP (const \fBCoordinates\fP &p1, const \fBCoordinates\fP &p2) const "
.br
.ti -1c
.RI "float \fBevaluateRatio\fP (unsigned nbUsables) const "
.br
.ti -1c
.RI "float \fBthreadsEvaluateRatio\fP () const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBcreateExample\fP ()"
.br
.RI "\fIcreateExample \fP"
.in -1c
.in -1c
.in +1c
.ti -1c
.RI "void \fBinitSizeNeighbourhood\fP ()"
.br
.ti -1c
.RI "void \fBinitCoordNeighbourhoodManhattan\fP (const \fBCoordinates\fP &coord)"
.br
.ti -1c
.RI "void \fBinitNeighbourhoodManhattan\fP ()"
.br
.ti -1c
.RI "unsigned \fBparcelsRoadDistance\fP (const \fBCoordinates\fP &coord1, const \fBCoordinates\fP &coord2)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Classe chargée de travailler sur les données en entrée du problème pour trouver des solution réalisables, opitmisant les objectifs suivants :
.IP "1." 4
Maximimiser les nombres de parcelles exploitables
.IP "2." 4
Minimiser la moyenne, la plus grande ou la somme des ratios entre distance des cellules par les routes et distance directe (distance Manhattan ou Euclidienne)
.PP
.PP
On pourra éventuellement avoir plusieurs instances de \fBField\fP dans une \fBResolution\fP\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Resolution::Resolution (const \fBField\fP & _field, const \fBParameters\fP & _params)"
Constructeur de la casse résolution 
.PP
\fBParameters:\fP
.RS 4
\fI_field\fP Surface sur laquelle on travaille 
.br
\fI_params\fP Paramètres du problème 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void Resolution::createExample ()"

.PP
createExample 
.PP
\fBTest\fP
.RS 4
Utile seulement pour les tests 
.RE
.PP
.PP
.SS ""
.PP
Autres méthodes utiles 
.SS ""
.PP
.IP "\(bu" 2

.PP

.SS "float Resolution::evaluateRatio (unsigned nbUsables) const"
Evalue le ratio de toutes les solutions 
.PP
\fBReturns:\fP
.RS 4
la moyenne des ratios 
.RE
.PP

.SS "unsigned int Resolution::evaluateTotalUsable () const"
Compte le nombre total de parcelles exploitables sur la surface 
.PP
\fBReturns:\fP
.RS 4
nombre de parcelles exploitables
.RE
.PP
.SS ""
.PP
Evaluations 
.SS ""

.SS "unsigned Resolution::getRoadDistance (const \fBCoordinates\fP & coord1, const \fBCoordinates\fP & coord2) const\fC [inline]\fP"
Donne la distance par les routes stockée 
.PP
\fBParameters:\fP
.RS 4
\fIcoord1\fP Première coordonnée 
.br
\fIcoord2\fP Seconde coordonnée 
.RE
.PP
\fBReturns:\fP
.RS 4
La distance par le route, un entier non signé 
.RE
.PP

.SS "void Resolution::initCoordNeighbourhoodManhattan (const \fBCoordinates\fP & coord)"
Définit la matrice de voisinage avec les routes avec la distance Manhattan 
.SS "void Resolution::initNeighbourhoodManhattan ()"
Définit la matrice de voisinage avec les routes avec la distance Manhattan 
.SS "void Resolution::initSizeNeighbourhood ()"
Initialise la matrice de voisinage selon la taille de la surface 
.SS "float Resolution::manhattanRatioBetween2Parcels (const \fBCoordinates\fP & p1, const \fBCoordinates\fP & p2) const"
Calcule le ratio entre distance par la route et distance Manhattan entre deux positions 
.PP
\fBParameters:\fP
.RS 4
\fIp1\fP premières coordonnées 
.br
\fIp2\fP secondes coordonnées 
.RE
.PP
\fBReturns:\fP
.RS 4
le ratio, sous forme de flottant 
.RE
.PP

.SS "unsigned Resolution::parcelsRoadDistance (const \fBCoordinates\fP & coord1, const \fBCoordinates\fP & coord2)"
Calcule la distance par les routes entre deux cellules quelconques, en testant toutes les routs qui desservent la cellue et en respectant les paramètres 
.PP
\fBParameters:\fP
.RS 4
\fIcoord1\fP Coordonnée 'de départ' 
.br
\fIcoord2\fP Coordonnée 'd'arrivée' 
.RE
.PP
\fBReturns:\fP
.RS 4
la valeur, entier non signé, de distance la plus courte, entre les deux coordonnées, en passant par les routes 
.RE
.PP

.SS "void Resolution::set_params (const \fBParameters\fP & _params)"
Mutateur sur les paramètres du problème
.PP
.SS ""
.PP
Getters 
.SS ""
.PP
.SS ""
.PP
Setters 
.SS ""

.SS "float Resolution::threadsEvaluateRatio () const"
Evalue le ratio de toutes les solutions avec des threads 
.PP
\fBReturns:\fP
.RS 4
l'évaluation en flottant 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Urbanisme from the source code\&.
