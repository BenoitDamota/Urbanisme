.TH "Field" 3 "Jeudi 12 Mai 2016" "Version 0.5" "Urbanisme" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Field \- Classe représentant la surface -le terrain- et contenant les opérations que l'on effectue sur celui-ci\&. L'état d'une instance de cette classe à la fin de l'algorithme représente une solution trouvée après la recherche\&. On peut donc avoir plusieurs \fBField\fP lors d'une exécution\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Field\&.h>\fP
.SS "Fonctions membres publiques"

.in +1c
.ti -1c
.RI "unsigned \fBget_width\fP () const "
.br
.ti -1c
.RI "unsigned \fBget_height\fP () const "
.br
.ti -1c
.RI "std::list< \fBCoordinates\fP > & \fBget_insOuts\fP ()"
.br
.ti -1c
.RI "unsigned \fBgetNbParcels\fP () const "
.br
.ti -1c
.RI "void \fBset_width\fP (unsigned width)"
.br
.ti -1c
.RI "void \fBset_height\fP (unsigned height)"
.br
.ti -1c
.RI "void \fBadd_road\fP (unsigned col, unsigned row)"
.br
.ti -1c
.RI "void \fBadd_road\fP (const \fBCoordinates\fP &coords)"
.br
.ti -1c
.RI "void \fBadd_in_out\fP (const \fBCoordinates\fP &coords)"
.br
.ti -1c
.RI "void \fBadd_in_out\fP (unsigned col, unsigned row)"
.br
.ti -1c
.RI "State \fBat\fP (const \fBCoordinates\fP &pos) const "
.br
.ti -1c
.RI "State \fBoperator[]\fP (const \fBCoordinates\fP &pos) const "
.br
.ti -1c
.RI "void \fBoperator=\fP (const \fBField\fP &other)"
.br
.ti -1c
.RI "std::vector< std::vector< State > >::const_iterator \fBbegin\fP () const "
.br
.RI "\fIbegin \fP"
.ti -1c
.RI "std::vector< std::vector< State > >::const_iterator \fBend\fP () const "
.br
.RI "\fIend \fP"
.ti -1c
.RI "std::vector< std::vector< State > >::iterator \fBbegin\fP ()"
.br
.RI "\fIbegin \fP"
.ti -1c
.RI "std::vector< std::vector< State > >::iterator \fBend\fP ()"
.br
.RI "\fIend \fP"
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBField\fP (unsigned width, unsigned height)"
.br
.ti -1c
.RI "\fBField\fP (const \fBField\fP &other)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBresizeWithDimensions\fP ()"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBshow_ins_and_outs\fP () const "
.br
.ti -1c
.RI "std::ostream & \fBprint\fP (std::ostream &out) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "bool \fBcontains\fP (int x, int y) const "
.br
.ti -1c
.RI "bool \fBcontains\fP (const \fBCoordinates\fP &coord) const "
.br
.ti -1c
.RI "bool \fBnextCoordinates\fP (\fBCoordinates\fP *coord) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBcreateExample\fP ()"
.br
.RI "\fIcreateExample \fP"
.in -1c
.in -1c
.SS "Fonctions membres publiques statiques"

.in +1c
.ti -1c
.RI "static \fBCoordinates\fP & \fBfirst\fP ()"
.br
.in -1c
.SS "Amis"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &out, const \fBField\fP &field)"
.br
.in -1c
.in +1c
.ti -1c
.RI "void \fBgenerateInsAndOuts\fP (unsigned nb)"
.br
.ti -1c
.RI "std::list< \fBCoordinates\fP > * \fBgetNeighbourRoads\fP (const \fBCoordinates\fP &coord) const "
.br
.ti -1c
.RI "std::list< \fBCoordinates\fP > * \fBgetCloseUnusableParcels\fP (const \fBCoordinates\fP &coord, unsigned servingDistance) const "
.br
.ti -1c
.RI "std::list< \fBCoordinates\fP > * \fBgetCloseParcels\fP (const \fBCoordinates\fP &coord, unsigned maxDist) const "
.br
.ti -1c
.RI "std::list< \fBCoordinates\fP > * \fBgetCloseRoads\fP (const \fBCoordinates\fP &coord, unsigned maxDist) const "
.br
.ti -1c
.RI "std::list< \fBCoordinates\fP > * \fBgetServingRoads\fP (const \fBCoordinates\fP &coord, unsigned servingDistance) const "
.br
.ti -1c
.RI "bool \fBhasServingRoad\fP (const \fBCoordinates\fP &coord, unsigned servingDistance) const "
.br
.ti -1c
.RI "void \fBdefineUsables\fP (unsigned servingDistance)"
.br
.ti -1c
.RI "void \fBupdateUsables\fP (unsigned servingDistance)"
.br
.in -1c
.SH "Description détaillée"
.PP 
Classe représentant la surface -le terrain- et contenant les opérations que l'on effectue sur celui-ci\&. L'état d'une instance de cette classe à la fin de l'algorithme représente une solution trouvée après la recherche\&. On peut donc avoir plusieurs \fBField\fP lors d'une exécution\&. 
.SH "Documentation des constructeurs et destructeur"
.PP 
.SS "Field::Field (unsigned width, unsigned height)"
Constructeur de la classe 
.PP
\fBParamètres:\fP
.RS 4
\fIwidth\fP Largeur à définir de la surface 
.br
\fIheight\fP Hauteur à définir de la surface
.RE
.PP
.SS ""
.PP
Constructeurs et destructeurs 
.SS ""

.SS "Field::Field (const \fBField\fP & other)"
Constructeur par recopie de la classe \fBField\fP 
.PP
\fBParamètres:\fP
.RS 4
\fIother\fP Instance à recopier 
.RE
.PP

.SH "Documentation des fonctions membres"
.PP 
.SS "void Field::add_in_out (const \fBCoordinates\fP & coords)\fC [inline]\fP"
Ajoute une entrée/sortie à partir de coordonnées 
.PP
\fBParamètres:\fP
.RS 4
\fIcoords\fP Coordonnées de l'E/S 
.RE
.PP

.SS "void Field::add_in_out (unsigned col, unsigned row)\fC [inline]\fP"
Ajoute une entrée/sortie à partir de coordonnées 
.PP
\fBParamètres:\fP
.RS 4
\fIcol\fP Colonne de l'E/S 
.br
\fIrow\fP Ligne de l'E/S 
.RE
.PP

.SS "void Field::add_road (unsigned col, unsigned row)\fC [inline]\fP"
Ajoute une route à partir de coordonnées 
.PP
\fBParamètres:\fP
.RS 4
\fIcol\fP Colonne de la route 
.br
\fIrow\fP Ligne de la route 
.RE
.PP

.SS "void Field::add_road (const \fBCoordinates\fP & coords)\fC [inline]\fP"
Ajoute une route à partir de coordonnées 
.PP
\fBParamètres:\fP
.RS 4
\fIcoords\fP Coordonnées de la future route 
.RE
.PP

.SS "State Field::at (const \fBCoordinates\fP & pos) const\fC [inline]\fP"
=== Operators === Retourne la parcelle de la surface aux coordonnées passées en paramètre 
.PP
\fBParamètres:\fP
.RS 4
\fIpos\fP Coordonnées de la parcelle 
.RE
.PP
\fBRenvoie:\fP
.RS 4
L'état de la parcelle à la position des coordonnées, un State 
.RE
.PP

.SS "std::vector<std::vector<State> >::const_iterator Field::begin () const\fC [inline]\fP"

.PP
begin 
.PP
\fBRenvoie:\fP
.RS 4
un itérateur constant sur la première parcelle du \fBField\fP 
.RE
.PP
\fBVoir également:\fP
.RS 4
.RE
.PP

.SS "std::vector<std::vector<State> >::iterator Field::begin ()\fC [inline]\fP"

.PP
begin 
.PP
\fBRenvoie:\fP
.RS 4
un itérateur sur la première parcelle du \fBField\fP 
.RE
.PP
\fBVoir également:\fP
.RS 4
.RE
.PP

.SS "bool Field::contains (int x, int y) const"
=== Fonctions sur les coordonnées === Effectue un test d'appartenance des coordonnées à la matrice 
.PP
\fBParamètres:\fP
.RS 4
\fIx\fP abscisse de la coordonnée 
.br
\fIy\fP ordonnée de la coordonnée 
.RE
.PP
\fBRenvoie:\fP
.RS 4
true si la coordonnée appartient à la matrice
.RE
.PP
.SS ""
.PP
=== Fonctions sur les coordonnées ===/// 
.SS ""

.SS "bool Field::contains (const \fBCoordinates\fP & coord) const"
Effectue un test d'appartenance des coordonnées à la matrice 
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnées de la position 
.RE
.PP
\fBRenvoie:\fP
.RS 4
true si la coordonnée appartient à la matrice 
.RE
.PP

.SS "void Field::createExample ()"

.PP
createExample 
.PP
\fBTest\fP
.RS 4
Utile seulement pour les tests 
.RE
.PP
.PP
.SS ""
.PP
Autres méthodes utiles 
.SS ""

.SS "void Field::defineUsables (unsigned servingDistance)"
Définit les parcelles dans le voisinage d'une route comme étant exploitables 
.PP
\fBParamètres:\fP
.RS 4
\fIservingDistance\fP Distance maximale du voisinage 
.RE
.PP

.SS "std::vector<std::vector<State> >::const_iterator Field::end () const\fC [inline]\fP"

.PP
end 
.PP
\fBRenvoie:\fP
.RS 4
un itérateur constant sur la dernière parcelle du \fBField\fP 
.RE
.PP
\fBVoir également:\fP
.RS 4
.RE
.PP

.SS "std::vector<std::vector<State> >::iterator Field::end ()\fC [inline]\fP"

.PP
end 
.PP
\fBRenvoie:\fP
.RS 4
un itérateur sur la dernière parcelle du \fBField\fP 
.RE
.PP
\fBVoir également:\fP
.RS 4
.RE
.PP

.SS "static \fBCoordinates\fP& Field::first ()\fC [inline]\fP, \fC [static]\fP"
Retourne la première coordonée de la matrice, elle peut ensuite être modifée pour servir d'itérateur à l'aide de \fBnextCoordinates()\fP 
.PP
\fBRenvoie:\fP
.RS 4
une référence, non constante, sur la première coordonnée de la matrice 
.RE
.PP

.SS "void Field::generateInsAndOuts (unsigned nb)"
=== Méthodes générales === Crée aléatoirement des entrées et sorties 
.PP
\fBParamètres:\fP
.RS 4
\fInb\fP nombre d'entrées et sorties à générer
.RE
.PP
.SS ""
.PP
=== Méthodes générales ===/ 
.SS ""

.SS "unsigned Field::get_height () const\fC [inline]\fP"
Accesseur sur le nombre de lignes -la hauteur- de la surface 
.PP
\fBRenvoie:\fP
.RS 4
La hauteur de la surface 
.RE
.PP

.SS "std::list<\fBCoordinates\fP>& Field::get_insOuts ()\fC [inline]\fP"
Accesseur sur la liste des entrées et sorties 
.PP
\fBRenvoie:\fP
.RS 4

.RE
.PP

.SS "unsigned Field::get_width () const\fC [inline]\fP"
Accesseur sur le nombre de colonnes -la largeur- de la surface 
.PP
\fBRenvoie:\fP
.RS 4
La largeur de la surface 
.RE
.PP

.SS "std::list< \fBCoordinates\fP > * Field::getCloseParcels (const \fBCoordinates\fP & coord, unsigned maxDist) const"
Recherche des parcelles qui sont proches de la position 
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnées de la position 
.br
\fImaxDist\fP Distance maximale entre la parcelle et la position 
.RE
.PP
\fBRenvoie:\fP
.RS 4
une liste de parcelles proches de la position donnée 
.RE
.PP

.SS "std::list< \fBCoordinates\fP > * Field::getCloseRoads (const \fBCoordinates\fP & coord, unsigned maxDist) const"
Recherche des routes qui sont proches de la position 
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnées de la position 
.br
\fImaxDist\fP Distance maximale entre la route et la position 
.RE
.PP
\fBRenvoie:\fP
.RS 4
une liste de routes proches de la position donnée 
.RE
.PP

.SS "std::list< \fBCoordinates\fP > * Field::getCloseUnusableParcels (const \fBCoordinates\fP & coord, unsigned servingDistance) const"
Recherche des parcelles qui serait desservies grâce au passage de la parcelle en route 
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnées de la parcelle 
.br
\fIservingDistance\fP Distance à laquelle les routes rendent les parcelles utilisables 
.RE
.PP
\fBRenvoie:\fP
.RS 4
une liste de parcelles qui deviendraient utilisables si la parcelle devenait une route 
.RE
.PP

.SS "unsigned Field::getNbParcels () const\fC [inline]\fP"
Donne le nombre de parcelles de la surface 
.PP
\fBRenvoie:\fP
.RS 4
Le nombre de parcelles, nombre de ligne facteur nombre de colonnes, un entier non signé 
.RE
.PP

.SS "std::list< \fBCoordinates\fP > * Field::getNeighbourRoads (const \fBCoordinates\fP & coord) const"
Recherche des parcelles qui sont concomitantes à la cellule 
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnées de la parcelle 
.RE
.PP
\fBRenvoie:\fP
.RS 4
une liste de parcelle adjacentes à la cellule Recherche des portions de routes qui sont concomitantes à la parcelle courante 
.RE
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnées de la parcelle 
.RE
.PP
\fBRenvoie:\fP
.RS 4
une liste de routes adjacentes à la parcelle 
.RE
.PP

.SS "std::list< \fBCoordinates\fP > * Field::getServingRoads (const \fBCoordinates\fP & coord, unsigned servingDistance) const"
Recherche des portions de routes qui peuvent désservir la parcelle 
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnées de la parcelle à desservir 
.br
\fIservingDistance\fP Distance maximale à laquelle un route peut desservir une parcelle 
.RE
.PP
\fBRenvoie:\fP
.RS 4
une liste de routes distance inférieure ou égale à la distance de desserte 
.RE
.PP
On vérifie ((2\&.servingDistance)+1)² parcelles, alors qu'on pourrait en vérifier moins 
.SS "bool Field::hasServingRoad (const \fBCoordinates\fP & coord, unsigned servingDistance) const"
Vérifie que la parcelle a un voisin 
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnées de la parcelle à desservir 
.br
\fIservingDistance\fP Distance de desserte des routes 
.RE
.PP
\fBRenvoie:\fP
.RS 4
vrai si la parcelle est desservie par au moins une route 
.RE
.PP
On vérifie ((2\&.serve_dist)+1)² parcelles, alors qu'on pourrait en vérifier moins 
.SS "bool Field::nextCoordinates (\fBCoordinates\fP * coord) const"
Modifie la coordonnée en entrée pour obtenir celle qu'elle précède Agit comme une itération sur l'ensemble des coordonnées de la surface 
.PP
\fBParamètres:\fP
.RS 4
\fIcoord\fP Coordonnée courante, va être modifiée pour devenir sa 'suivante'\&. Elle est non modifiée si il n'y a pas de suivante\&. 
.RE
.PP
\fBRenvoie:\fP
.RS 4
vrai si il y a une coordonnées, faux si on est à la fin ou en dehors de la surface 
.RE
.PP

.SS "void Field::operator= (const \fBField\fP & other)\fC [inline]\fP"
Opérateur = d'affectation 
.PP
\fBParamètres:\fP
.RS 4
\fIother\fP Instance à recopier 
.RE
.PP

.SS "State Field::operator[] (const \fBCoordinates\fP & pos) const\fC [inline]\fP"
Opérateur [] avec des coordonnées sur la surface, retourne la parcelle de la surface aux coordonnées passées en paramètre 
.PP
\fBParamètres:\fP
.RS 4
\fIpos\fP Coordonnées de la parcelle 
.RE
.PP
\fBRenvoie:\fP
.RS 4
L'état de la parcelle à la position des coordonnées, un State 
.RE
.PP

.SS "std::ostream & Field::print (std::ostream & out) const"
Imprime dans un flux les informations de l'instance 
.PP
\fBParamètres:\fP
.RS 4
\fIout\fP Flux dans lequel on imprime les informations 
.RE
.PP
\fBRenvoie:\fP
.RS 4
Le flux en entrée sur lequel on a imprimé les informations 
.RE
.PP

.SS "void Field::resizeWithDimensions ()"
Redéfinit la taille du vecteur de vecteur d'états selon le nombre de lignes et de colonnes contenues dans la classe\&. On utilise la fonction resize()\&. Attention, les données contenues dans le vecteur peuvent être modifiées
.PP
.SS ""
.PP
Setters 
.SS ""

.SS "void Field::set_height (unsigned height)\fC [inline]\fP"
Mutateur sur le nombre de lignes -la hauteur- de la surface 
.PP
\fBParamètres:\fP
.RS 4
\fIheight\fP La nouvelle hauteur de la surface 
.RE
.PP

.SS "void Field::set_width (unsigned width)\fC [inline]\fP"
Mutateur sur le nombre de colonnes -la largeur- de la surface 
.PP
\fBParamètres:\fP
.RS 4
\fIwidth\fP La nouvelle largeur de la surface 
.RE
.PP

.SS "void Field::show_ins_and_outs () const"
Impression sur la sortie standard des entrées et sorties de la surface
.PP
.SS ""
.PP
Affichage 
.SS ""

.SS "void Field::updateUsables (unsigned servingDistance)"
Met à jour les parcelles dans le voisinage d'une route comme étant exploitables 
.PP
\fBParamètres:\fP
.RS 4
\fIservingDistance\fP Distance maximale du voisinage 
.RE
.PP

.SH "Documentation des fonctions amies et associées"
.PP 
.SS "std::ostream& operator<< (std::ostream & out, const \fBField\fP & field)\fC [friend]\fP"
Surcharge de l'opérateur << de sortie sur flux 
.PP
\fBParamètres:\fP
.RS 4
\fIout\fP Flux dans lequel on imprime les informations 
.br
\fIfield\fP Surface que l'on souhaite imprimer 
.RE
.PP
\fBRenvoie:\fP
.RS 4
Le flux en entrée sur lequel on a imprimé les informations de la surface passée en entrée 
.RE
.PP


.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour Urbanisme à partir du code source\&.
